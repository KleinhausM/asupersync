{
  "schema_version": "1.0.0",
  "map_id": "lean.runtime_state_refinement_map.v1",
  "title": "RuntimeState + Scheduler/Combinator Operations to Lean Formal Rules",
  "scope": "Explicit Rust RuntimeState plus scheduler/combinator operation mappings to Lean Step labels and theorem obligations for Track-4 refinement closure (bd-23hq7).",
  "source_files": [
    "src/runtime/state.rs",
    "src/runtime/scheduler/three_lane.rs",
    "src/cx/scope.rs",
    "formal/lean/Asupersync.lean",
    "formal/lean/coverage/theorem_surface_inventory.json",
    "formal/lean/coverage/step_constructor_coverage.json"
  ],
  "divergence_triage_decision_matrix": {
    "matrix_id": "lean.divergence_repair_decision.v1",
    "purpose": "Deterministic routing policy for Rust-vs-Lean divergence triage in Track-4.",
    "required_inputs": [
      "first_divergence_signature",
      "failing_theorems_with_lines",
      "affected_runtime_operation_ids",
      "counterexample_or_replay_trace",
      "assumption_or_harness_delta"
    ],
    "decision_routes": [
      {
        "route_id": "code-first",
        "trigger_conditions": [
          "Lean theorem is stable and mapped to operation IDs touched by recent Rust changes.",
          "Executable conformance and/or replay evidence shows runtime behavior violating mapped theorem assumptions."
        ],
        "required_evidence": [
          "Rust diff touches mapped operation",
          "Conformance mismatch or replay divergence artifact",
          "No unresolved model-side theorem obligations for the failing rule family"
        ],
        "patch_targets": [
          "src/runtime/**",
          "tests/refinement_conformance.rs"
        ],
        "fix_direction": "runtime-code",
        "owner_assignment": {
          "primary_owner_role": "Rust runtime owner",
          "secondary_owner_role": "Conformance owner",
          "escalation_owner_role": "CI/governance owner"
        },
        "required_artifact_updates": [
          "formal/lean/coverage/runtime_state_refinement_map.json",
          "formal/lean/coverage/theorem_rule_traceability_ledger.json",
          "formal/lean/coverage/baseline_report_v1.json"
        ],
        "ci_conformance_failure_references": [
          "tests/refinement_conformance.rs",
          "formal/lean/coverage/ci_verification_profiles.json"
        ],
        "sign_off_roles": [
          "Rust runtime owner",
          "Formal owner",
          "Conformance owner"
        ]
      },
      {
        "route_id": "model-first",
        "trigger_conditions": [
          "Mismatch is caused by missing/unstable Lean proof obligations or helper ordering/shape issues.",
          "Rust behavior is consistent with existing executable tests and intended invariants."
        ],
        "required_evidence": [
          "Lean frontier bucket and theorem failure logs",
          "Traceability row showing mapping exists but theorem branch is incomplete",
          "No contradictory Rust conformance failure for the same operation"
        ],
        "patch_targets": [
          "formal/lean/Asupersync.lean",
          "formal/lean/coverage/*.json"
        ],
        "fix_direction": "formal-model",
        "owner_assignment": {
          "primary_owner_role": "Formal owner",
          "secondary_owner_role": "Rust runtime owner",
          "escalation_owner_role": "CI/governance owner"
        },
        "required_artifact_updates": [
          "formal/lean/Asupersync.lean",
          "formal/lean/coverage/lean_frontier_buckets_v1.json",
          "formal/lean/coverage/baseline_report_v1.json"
        ],
        "ci_conformance_failure_references": [
          "target/lean-e2e/*_lake_build.log",
          "formal/lean/coverage/ci_verification_profiles.json"
        ],
        "sign_off_roles": [
          "Formal owner",
          "Rust runtime owner",
          "CI/governance owner"
        ]
      },
      {
        "route_id": "assumptions-or-harness-first",
        "trigger_conditions": [
          "Observed mismatch is due to stale assumptions, missing fixture constraints, or harness comparability drift.",
          "Neither Rust implementation nor Lean model needs semantic change after evidence reconciliation."
        ],
        "required_evidence": [
          "Assumption mismatch checklist",
          "Harness/profile mismatch report",
          "Updated deterministic repro command proving resolution"
        ],
        "patch_targets": [
          "formal/lean/coverage/ci_verification_profiles.json",
          "tests/*refinement*",
          "docs/replay-debugging.md"
        ],
        "fix_direction": "assumption-harness",
        "owner_assignment": {
          "primary_owner_role": "Conformance owner",
          "secondary_owner_role": "Formal owner",
          "escalation_owner_role": "Runtime owner"
        },
        "required_artifact_updates": [
          "formal/lean/coverage/ci_verification_profiles.json",
          "formal/lean/coverage/runtime_state_refinement_map.json",
          "formal/lean/coverage/baseline_report_v1.json"
        ],
        "ci_conformance_failure_references": [
          "tests/refinement_conformance.rs",
          "formal/lean/coverage/ci_verification_profiles.json"
        ],
        "sign_off_roles": [
          "Conformance owner",
          "Formal owner",
          "Runtime owner"
        ]
      }
    ],
    "audit_requirements": [
      "Every divergence note must record selected route_id and rejected alternatives.",
      "Every route must list concrete artifacts and owning sign-off roles before closure.",
      "Route changes require an explicit note update in the owning bead thread."
    ]
  },
  "divergence_triage_examples": [
    {
      "example_id": "triage-example.bd-cspxm.2026-02-11",
      "bead_id": "bd-cspxm",
      "summary": "Lean preservation proofs failed due to proof-shape/declaration-order issues in setTask/setRegion cancellation branches.",
      "selected_route": "model-first",
      "rejected_routes": [
        "code-first",
        "assumptions-or-harness-first"
      ],
      "owner_assignment_decision": {
        "primary_owner_role": "Formal owner",
        "assigned_bead_owner": "bd-cspxm owner",
        "escalation_owner_role": "CI/governance owner"
      },
      "decision_rationale": [
        "Failure frontier was concentrated in Lean theorem proof-shape errors, not runtime behavior drift.",
        "Rust conformance behavior for mapped operations remained consistent during the same window.",
        "Fixes were localized to Lean helper ordering and branch proof structure."
      ],
      "artifact_updates": [
        "formal/lean/Asupersync.lean",
        "formal/lean/coverage/lean_frontier_buckets_v1.json",
        "formal/lean/coverage/baseline_report_v1.json"
      ],
      "ci_conformance_reference": {
        "profile": "frontier",
        "failure_bucket": "proof-shape.type-mismatch",
        "conformance_test": "refinement_trace_equivalence_detects_semantic_mismatch"
      },
      "evidence": [
        {
          "artifact": "target/lean-e2e/bd-cspxm_frontier.json",
          "kind": "lean_frontier",
          "note": "Diagnostics reduced from 113 to 86 with declaration-order bucket elimination."
        },
        {
          "artifact": "target/lean-e2e/bd-cspxm_lake_build.log",
          "kind": "lean_build_log",
          "note": "Captured deterministic failure classes before/after proof refactor."
        },
        {
          "artifact": "formal/lean/Asupersync.lean",
          "kind": "model_patch_surface",
          "note": "Refactor applied to substitution/rewrite helpers and cancelRequest preservation branch binders."
        }
      ],
      "sign_off_roles": [
        "Formal owner",
        "Rust runtime owner",
        "CI/governance owner"
      ],
      "outcome": "Route held as model-first; Track-2 frontier buckets moved from 8 to 7 while keeping runtime mapping intact."
    }
  ],
  "mappings": [
    {
      "operation_id": "runtime_state.create_obligation",
      "rust_method": {
        "name": "create_obligation",
        "file_path": "src/runtime/state.rs",
        "line": 1129
      },
      "owner": "runtime-state-owner",
      "update_trigger_conditions": [
        "Any semantic change to create_obligation input/output behavior or region admission policy.",
        "Any change to obligation creation bookkeeping fields or ownership invariants in RuntimeState."
      ],
      "formal_labels": [
        "step.reserve"
      ],
      "theorem_obligations": [
        {
          "theorem": "reserve_creates_reserved",
          "line": 1032
        },
        {
          "theorem": "reserve_preserves_wellformed",
          "line": 1987
        }
      ],
      "assumptions": [
        "Target region exists and is admission-open for obligations.",
        "Caller provides a holder TaskId that belongs to the target region under runtime ownership invariants."
      ],
      "disambiguation_notes": []
    },
    {
      "operation_id": "runtime_state.commit_obligation",
      "rust_method": {
        "name": "commit_obligation",
        "file_path": "src/runtime/state.rs",
        "line": 1197
      },
      "owner": "runtime-state-owner",
      "update_trigger_conditions": [
        "Any semantic change to commit_obligation state transitions, error handling, or resolution side effects.",
        "Any change to commit-related ledger counters, region-progress propagation, or post-commit cleanup."
      ],
      "formal_labels": [
        "step.commit"
      ],
      "theorem_obligations": [
        {
          "theorem": "commit_resolves",
          "line": 675
        },
        {
          "theorem": "commit_removes_from_ledger",
          "line": 723
        },
        {
          "theorem": "commit_preserves_wellformed",
          "line": 2277
        },
        {
          "theorem": "commit_resolves_obligation",
          "line": 3505
        }
      ],
      "assumptions": [
        "Obligation exists in Reserved state before commit.",
        "Region record remains reachable so pending-obligation counters are decremented.",
        "advance_region_state is invoked after resolution to propagate close progress."
      ],
      "disambiguation_notes": []
    },
    {
      "operation_id": "runtime_state.abort_obligation",
      "rust_method": {
        "name": "abort_obligation",
        "file_path": "src/runtime/state.rs",
        "line": 1245
      },
      "owner": "runtime-state-owner",
      "update_trigger_conditions": [
        "Any semantic change to abort_obligation behavior, reason classification, or abort-path side effects.",
        "Any change to abort-related ledger accounting or region-state progression hooks."
      ],
      "formal_labels": [
        "step.abort"
      ],
      "theorem_obligations": [
        {
          "theorem": "abort_resolves",
          "line": 691
        },
        {
          "theorem": "abort_removes_from_ledger",
          "line": 747
        },
        {
          "theorem": "abort_preserves_wellformed",
          "line": 2286
        },
        {
          "theorem": "abort_resolves_obligation",
          "line": 3518
        }
      ],
      "assumptions": [
        "Obligation exists in Reserved state before abort.",
        "Abort reason classification is implementation-only metadata and does not alter Step.abort semantics.",
        "advance_region_state is invoked after resolution to propagate close progress."
      ],
      "disambiguation_notes": []
    },
    {
      "operation_id": "runtime_state.mark_obligation_leaked",
      "rust_method": {
        "name": "mark_obligation_leaked",
        "file_path": "src/runtime/state.rs",
        "line": 1300
      },
      "owner": "runtime-state-owner",
      "update_trigger_conditions": [
        "Any change to leak detection policy, leak marking semantics, or leak-state transitions.",
        "Any change to runtime leak response behavior that affects close/quiescence progress assumptions."
      ],
      "formal_labels": [
        "step.leak"
      ],
      "theorem_obligations": [
        {
          "theorem": "leak_marks_leaked",
          "line": 707
        },
        {
          "theorem": "leak_removes_from_ledger",
          "line": 770
        },
        {
          "theorem": "leak_preserves_wellformed",
          "line": 2295
        }
      ],
      "assumptions": [
        "Obligation exists and is unresolved when leak is marked.",
        "Leak response policy (panic/recover/silent) is an implementation-level control that wraps, but does not replace, Step.leak semantics.",
        "advance_region_state is invoked after leak resolution bookkeeping."
      ],
      "disambiguation_notes": []
    },
    {
      "operation_id": "runtime_state.cancel_request",
      "rust_method": {
        "name": "cancel_request",
        "file_path": "src/runtime/state.rs",
        "line": 1530
      },
      "owner": "runtime-state-owner",
      "update_trigger_conditions": [
        "Any change to cancel propagation order, descendant traversal strategy, or cause-chain strengthening behavior.",
        "Any change to cancel request staging that affects acknowledge/finalize/complete handoff assumptions."
      ],
      "formal_labels": [
        "step.cancelRequest",
        "step.cancelPropagate",
        "step.cancelChild"
      ],
      "theorem_obligations": [
        {
          "theorem": "cancelRequest_preserves_wellformed",
          "line": 2373
        },
        {
          "theorem": "cancel_step_strengthens_reason",
          "line": 3475
        },
        {
          "theorem": "cancel_propagation_bounded",
          "line": 3333
        },
        {
          "theorem": "cancel_protocol_terminates",
          "line": 3254
        }
      ],
      "assumptions": [
        "Target region exists; descendants are collected from the region tree and processed parent-first.",
        "Task-level acknowledgement/finalize/complete transitions occur in later scheduler polls after CancelRequested is installed.",
        "Cause-chain strengthening follows attribution limits configured in RuntimeState."
      ],
      "disambiguation_notes": [
        "The root region request maps to step.cancelRequest, while descendant propagation maps to step.cancelPropagate/step.cancelChild.",
        "This method does not itself execute cancelAcknowledge/cancelFinalize/cancelComplete constructors; those occur in subsequent task polling."
      ]
    },
    {
      "operation_id": "runtime_state.task_completed",
      "rust_method": {
        "name": "task_completed",
        "file_path": "src/runtime/state.rs",
        "line": 1805
      },
      "owner": "runtime-state-owner",
      "update_trigger_conditions": [
        "Any semantic change to task completion cleanup, obligation abort policy, or membership removal ordering.",
        "Any change to task_completed interactions with advance_region_state and close-progress signaling."
      ],
      "formal_labels": [
        "step.complete",
        "step.abort",
        "step.closeChildrenDone"
      ],
      "theorem_obligations": [
        {
          "theorem": "complete_preserves_region",
          "line": 1279
        },
        {
          "theorem": "complete_preserves_wellformed",
          "line": 1558
        },
        {
          "theorem": "abort_preserves_wellformed",
          "line": 2286
        },
        {
          "theorem": "close_children_exist_completed",
          "line": 1407
        }
      ],
      "assumptions": [
        "Completed task is removed from task table and owner region membership.",
        "Pending obligations held by the completed task are aborted to preserve close progress.",
        "Region progression effects are delegated to advance_region_state."
      ],
      "disambiguation_notes": [
        "Primary transition is step.complete for the finished task.",
        "Additional step.abort obligations can be emitted for orphaned permits during cleanup.",
        "Region-close progress signaling is represented by step.closeChildrenDone and subsequent close-phase constructors via advance_region_state."
      ]
    },
    {
      "operation_id": "runtime_state.advance_region_state",
      "rust_method": {
        "name": "advance_region_state",
        "file_path": "src/runtime/state.rs",
        "line": 2120
      },
      "owner": "runtime-state-owner",
      "update_trigger_conditions": [
        "Any change to close-phase transition ordering or termination conditions in advance_region_state.",
        "Any change to finalizer progress barriers, quiescence checks, or pending-obligation close requirements."
      ],
      "formal_labels": [
        "step.closeBegin",
        "step.closeCancelChildren",
        "step.closeChildrenDone",
        "step.closeRunFinalizer",
        "step.close"
      ],
      "theorem_obligations": [
        {
          "theorem": "close_begin_step",
          "line": 1747
        },
        {
          "theorem": "close_cancel_children_step",
          "line": 1757
        },
        {
          "theorem": "close_children_done_step",
          "line": 1782
        },
        {
          "theorem": "close_run_finalizer_step",
          "line": 1794
        },
        {
          "theorem": "close_complete_step",
          "line": 1806
        },
        {
          "theorem": "close_implies_quiescent",
          "line": 794
        },
        {
          "theorem": "close_implies_ledger_empty",
          "line": 808
        },
        {
          "theorem": "close_produces_closed_region",
          "line": 3492
        }
      ],
      "assumptions": [
        "Region exists and is already in a close-phase state (Closing/Draining/Finalizing).",
        "Final close requires no children, no live tasks, no pending obligations, and finalizers drained.",
        "Async finalizers create scheduling barriers until completion."
      ],
      "disambiguation_notes": [
        "advance_region_state is an iterative driver and can realize multiple close-phase constructors within one call.",
        "Whether closeCancelChildren or closeChildrenDone is taken depends on current region liveness and child/subregion sets."
      ]
    },
    {
      "operation_id": "scheduler.three_lane.next_task",
      "rust_method": {
        "name": "next_task",
        "file_path": "src/runtime/scheduler/three_lane.rs",
        "line": 1161
      },
      "owner": "scheduler-owner",
      "update_trigger_conditions": [
        "Any change to cancel/timed/ready lane priority semantics, fairness yield policy, or deterministic tie-breaking.",
        "Any change to scheduler dispatch/stuttering trace signatures or related conformance harness expectations."
      ],
      "formal_labels": [
        "step.scheduleStep",
        "step.schedule",
        "step.tick"
      ],
      "theorem_obligations": [
        {
          "theorem": "scheduler_change_preserves_wellformed",
          "line": 2721
        },
        {
          "theorem": "scheduleStep_preserves_wellformed_constructor",
          "line": 3800
        },
        {
          "theorem": "schedule_preserves_wellformed_constructor",
          "line": 3809
        },
        {
          "theorem": "stuttering_preserves_wellformed",
          "line": 3397
        }
      ],
      "assumptions": [
        "Lane selection is deterministic under fixed queue contents and deterministic harness seed.",
        "Fairness-yield paths keep scheduler progress bounded by cancel_streak_limit when non-cancel work exists.",
        "Dispatch updates are represented by scheduleStep/schedule transitions; no-dispatch iterations are represented as stuttering/tick."
      ],
      "disambiguation_notes": [
        "step.scheduleStep models dequeue/selection of next runnable task; step.schedule models the selected task-state progression.",
        "Fairness-yield and idle loop iterations are modeled by stuttering/tick signatures rather than semantic state transitions."
      ],
      "expected_trace_signatures": [
        "sched.schedule_step.dispatches_selected_task",
        "sched.cancel_streak_yield.ready_or_timed_visible",
        "sched.stuttering.idle_or_fairness_yield"
      ],
      "conformance_test_links": [
        "tests/refinement_conformance.rs:446",
        "tests/refinement_conformance.rs:587",
        "src/runtime/scheduler/three_lane.rs:3604"
      ]
    },
    {
      "operation_id": "scope.race_all_loser_drain",
      "rust_method": {
        "name": "race_all",
        "file_path": "src/cx/scope.rs",
        "line": 1044
      },
      "owner": "scope-combinator-owner",
      "update_trigger_conditions": [
        "Any change to race winner selection determinism, loser cancellation policy, or drain-before-return guarantee.",
        "Any change to scope.race_all cancellation/finalization sequencing that impacts quiescence observability."
      ],
      "formal_labels": [
        "step.cancelRequest",
        "step.cancelAcknowledge",
        "step.cancelFinalize",
        "step.cancelComplete",
        "step.closeChildrenDone"
      ],
      "theorem_obligations": [
        {
          "theorem": "cancel_protocol_terminates",
          "line": 3254
        },
        {
          "theorem": "cancel_propagation_bounded",
          "line": 3333
        },
        {
          "theorem": "close_implies_quiescent",
          "line": 794
        },
        {
          "theorem": "close_quiescence_decomposition",
          "line": 889
        }
      ],
      "assumptions": [
        "Winner index selection is deterministic under fixed harness seed and stable task polling order.",
        "All loser handles receive cancel reason race_loser and are awaited to terminal join state before return.",
        "Scope returns to caller only after loser-drain completes, preserving quiescence for the raced child set."
      ],
      "disambiguation_notes": [
        "cancelRequest/cancelAcknowledge/cancelFinalize/cancelComplete may span multiple scheduler polls and are linked by the race_loser cause chain.",
        "closeChildrenDone becomes observable after loser drain and finalizer progress complete for the raced subregion."
      ],
      "expected_trace_signatures": [
        "race_all.winner_selected.index_stable_under_seed",
        "race_all.loser_cancelled_with_race_loser",
        "race_all.losers_drained_before_return"
      ],
      "conformance_test_links": [
        "src/cx/scope.rs:1832",
        "tests/refinement_conformance.rs:487",
        "tests/refinement_conformance.rs:587"
      ]
    }
  ]
}
